---
title: "Association Rules II"
author: "Margaret Miró"
date: "21746 Data Mining 2022-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Association Rules: ECLAT

Let's continue learning other aspects of rule mining. In the slides you have a more detailed explanation on how ECLAT (Equivalence Class Transformation) constructs the frequent itemsets.

We have been considering Apriori as the basic algorithm for finding association rules, but there are others. The "arules" library also offers ECLAT. ECLAT improves Apriori in the step of extracting frequent itemsets. As you remember, Apriori has to scan the database multiple times to find the frequent itemsets. But with ECLAT there is no need to scan the database for counting the support for k-itemsets (k>=1). The basic idea for the eclat algorithm is use tidset intersections to compute the support of a candidate itemset avoiding the generation of subsets that does not exist in the prefix tree. It was originally proposed by Zaki, Parthasarathy et al. 

Let's start with a simple example where we create a list of items:
```{r}
mydata <- list(
  c("a", "b", "c"),
  c("a", "b"),
  c("a", "b", "d"),
  c("b", "e"),
  c("b", "c", "e"),
  c("a", "d", "e"),
  c("a", "c"),
  c("a", "b", "d"),
  c("c", "e"),
  c("a", "b", "d", "e")
)
```

The function "eclat()" gives frequent itemsets as an output. Afterwards, the command "ruleInduction()" extracts the rules from those itemsets. For the same minimum support, both algorithms (Apriori and Eclat) must give the same result.

```{r}
library(arules)
## Mine itemsets with tidLists.
f <- eclat(mydata, parameter = list(support = 0.1, tidLists = TRUE))
## Get dimensions of the tidLists.
dim(tidLists(f))
## Coerce tidLists to list.
as(tidLists(f), "list")
## Inspect visually.
image(tidLists(f))
## Show the Frequent itemsets and respective supports
inspect(f)
```

In order to work with the "arules" library, the data has to be in transaction format. If necessary, the data has to be converted into a transaction class. 
```{r}
t <- as(mydata, "transactions")
t
```

Let's make sure it's in the correct format.
```{r}
str(t)
```

Eclat also finds frequent itemsets from data in transaction format and generates the rules.
```{r}
f2 <- eclat(t, parameter = list(support = 0.1, tidLists = TRUE))
inspect(f2)
summary(f2)
```

```{r}
rulesf2 <- ruleInduction(f2, confidence = .7)
rulesf2
```

In order to see the rules:
```{r}
inspect(rulesf2)
```

## Association Rules using Apriori: Titanic example

### Dataset

The Titanic data set provides information on the fate of passengers on the fatal maiden voyage of the ocean liner ‘Titanic’, summarized according to economic status (class), sex, age and survival. This dataset is available in the R package datasets.
```{r}
str(Titanic)
```

The data is organized in a 4-dimensional array resulting from cross-tabulating 2201 observations on 4 variables. 
```{r}
Titanic
```

This dataset is not suitable suitable for association rule mining since we need to have "transactions". For this example, the rows (transactions) will represent the persons; and the items will be the values of the 4 attributes. 

We reconstruct the raw data as titanic.raw in which each row represents a person. 
```{r}
df <- as.data.frame(Titanic)
titanic.raw <- NULL
for (i in 1:4)
{
  titanic.raw <- cbind(
    titanic.raw,
    rep(as.character(df[, i]), df$Freq)
  )
}
titanic.raw <- as.data.frame(titanic.raw)
names(titanic.raw) <- names(df)[1:4]
```

Let's check the outcome
```{r}
dim(titanic.raw)
head(titanic.raw)
```

To get a general feeling for the data we type
```{r}
summary(titanic.raw)
```

### Frequent Itemsets

Find frequent itemsets for a support of 0.1 and maximum length 4.
```{r}
freqitem2 <- eclat(titanic.raw, parameter = list(supp = 0.1, maxlen = 4))
summary(freqitem2)
inspect(freqitem2)
```

### Association Rules

Using the frequent itemsets we just found, create the association rules for a 70% confidence.
```{r}
AR1 <- ruleInduction(freqitem2, confidence = .7)
AR1
```

We can also create the association rules directly using Apriori (default values):
```{r}
AR2 <- apriori(titanic.raw)
AR2
```

IMPORTANT: the function apriori(data,...) requires data to be an object of class transactions or any data structure which can be coerced into transactions (a binary matrix or data.frame). You may have to use the function "as()" to force your data to belong to the class transactions before you can apply the "apriori()" function.

The "inspect()" function will give a list of the rules. We have obtained too many rules. We will only consider rules with "Survived=No" and "Survived=Yes" in the right hand side (RHS), non-emptyset in the left hand side and we will also lower the support. 
```{r}
AR3 <- apriori(titanic.raw,
  parameter = list(minlen = 2, support = 0.005, confidence = 0.8),
  appearance = list(rhs = c("Survived=No", "Survived=Yes"), default = "lhs"),
  control = list(verbose = F)
)
inspect(AR3)
```

### Redundant Rules

Consider rules #1, #7. Rule #1 includes rule #7. Rule #7 provides no extra knowledge in addition to rule #1, since rules #1 tells us that all 2nd-class children survived. When a rule (such as #7) is a super rule of another rule (#1) and the former has the same or a lower lift, the former rule (#7) is considered to be redundant. Let's order the rules by lift.
```{r}
rules.sorted <- sort(AR3, by = "lift")
inspect(rules.sorted)
```

Once the rules are ordered by lift a simple analysis will allow us to find the redundant rules. Or we can find redundant rules automatically.
```{r}
inspect(rules.sorted[is.redundant(rules.sorted)])
```

Redundant rules don't give any additional information and can be pruned.  
```{r}
rules.pruned <- rules.sorted[!is.redundant(rules.sorted)]
inspect(rules.pruned)
```

Interpreting rule #1: The rule states only that all children of class 2 survived, but provides no information at all to compare the survival rates of different classes. We would need larger frequent itemsets with values for class and age in the LHS. Parameters have also been changed in order to have rules.
```{r}
AR4 <- apriori(titanic.raw,
  control = list(verbose = F),
  parameter = list(minlen = 3, supp = 0.002, conf = 0.2),
  appearance = list(
    default = "none", rhs = c("Survived=Yes"),
    lhs = c(
      "Class=1st", "Class=2nd", "Class=3rd",
      "Age=Child", "Age=Adult"
    )
  )
)

rules.sorted2 <- sort(AR4, by = "confidence")
inspect(rules.sorted2)
```

We can see that all children from first and second class survive.

### Evaluating the rules

R provides different interest measures that can be used to evaluate the rules. We only consider the pruned rules in the example below.
```{r}
interestMeasure(rules.pruned, c("support", "chiSquare", "confidence", "conviction", "cosine", "coverage", "leverage", "lift", "oddsRatio"), titanic.raw)
```

### Rule visualization

We will now depict some ways to visualize association rules which include scatter plots, balloon plots, graph-based visualizations,and parallel coordinates plots using the R package "arulesViz". 

* Scatter plot
```{r}
library(arulesViz)
plot(AR2)
```

* Balloon plot
```{r}
plot(rules.pruned, method = "grouped")
```

* Graph-based visualizations
```{r}
plot(rules.pruned, method = "graph")
```

## Association Rules using ECLAT: AdultUCI example

### Dataset

The AdultUCI data set contains the questionnaire data of the “Adult” database (originally called the “Census Income” Database) formatted as a data.frame. This data set contains 48842 observations on following 15 variables.
```{r}
data("AdultUCI")
str(AdultUCI)
summary(AdultUCI)
```

For more information on the data set type ?AdultUCI.

In order to create association rules we must coerce the data frame into transactions.
```{r eval = FALSE, echo = FALSE}
Adult <- as(AdultUCI, "transactions")
```

There is a problem with the variables. Association rules likes factor variables. We start by checking the type of columns.
```{r}
typeCols <- sapply(AdultUCI, class)
```

Retrieve list of columns that are qualitative / categorical variables. All integer variables have been removed.
```{r}
factCols <- grep("factor", typeCols)
subAdultUCI <- AdultUCI[, factCols]
head(subAdultUCI)
str(subAdultUCI)
```

Now, we again coerce into transactions.
```{r}
Adult <- as(subAdultUCI, "transactions")
summary(Adult)
```

### Frequent itemsets using ECLAT

To get a feeling for the data, we start by plotting frequent items.
```{r}
itemFrequencyPlot(Adult, support = 0.1, cex.names = 0.8)
```

Let's find the frequent itemsets:
```{r}
itemsets <- eclat(Adult, parameter = list(supp = 0.1, maxlen = 15), control = list(verbose = FALSE))
itemsets
summary(itemsets)
```

There are many frequent iemsets. To see the 1-itemsets:
```{r}
singleItems <- itemsets[size(items(itemsets)) == 1]
singleItems
```

### Association Rules using ECLAT

Now that we have the frequent itemsets, we construct the rules for a 70% minimum confidence.
```{r}
AR1_e <- ruleInduction(itemsets, confidence = .7)
AR1_e
```

Too many rules have been obtained, let's adjust the parameters:
```{r}
itemsets2 <- eclat(Adult, parameter = list(supp = 0.5, maxlen = 10), control = list(verbose = FALSE))
AR2_e <- ruleInduction(itemsets2, confidence = .8)
AR2_e
inspect(AR2_e)
```

These rules can be visualized, sorted, pruned, ....
